---
title: "future Slides"
author: Tomoya Sasaki
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  beamer_presentation:
    theme: "CambridgeUS"
    colortheme: "beaver"
    # incremental: true

---

```{r settings, echo=FALSE, message=FALSE}
here::i_am("PML Presentation/Partial/future.Rmd")
library(tidyverse)
knitr::knit_engines$set("rcpp")
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```


## Why parallelize

- Parallel computing is powerful and useful when you have time-consuming tasks


---

## Common issues in parallel computing


- Often need two different codes for parallel and non-parallel computing
  - Increase potential bugs
- Methods for parallel computing differ across operating systems
  - Parallelization with `mclapply` (Forking) does not work in Windows
  - Your choice of package would decide how to run in parallel

---

## \texttt{future} package 

- `future` provides a simple and uniform tool for async. parallel, and distributed processing in `R`
  - Same coding style between sequential and parallel tasks 
  - Users decide how to parallelize: the code does not depend on how to run in parallel
  
  <!-- - In programming, "future" can be thought as a value that will eventually become available -->
  <!-- - `future` implements this idea -->
  
  
```{r, eval=FALSE}
f <- future(expr) ## evaluate in parallel
r <- resolved(f) ## check if done
v <- value(f) ## get result
```

---

## Same coding style

```{r,eval=FALSE}
f3 <- function() {
  tmp <- rnorm(10000)
  for (i in 1:10000) {
    tmp <- tmp + i
  }
  sum(tmp)
}
value <- f3()

library(future)
future_obj <- future(f3())
value <- value(future_obj)
```

---
 
## Choose how to parallelize

- sequential: `plan(sequential)`
- parallelize on local machine: `plan(multisession)`
- "fork" your task (not fore Windows): `plan(multicore)`
- multiple local or remote computers `plan(cluster)` 

```{r, eval=FALSE}
library(future)
## multisession using two cores
## default setup uses the max # of cores
## print with future::availableCores()
plan(multisession, workers = 2)

future_obj <- future(f3())
value <- value(future_obj)

## check current plan
plan()

```

--- 

## User friendly functions

- Add "future_" in front of the function
- Evaluate, check, get result within one function

```{r, eval = FALSE}
## apply / future.apply
lapply(x, your_fun)

plan(multisession, workers = 2)
future_lapply(x, your_fun)
```

  - `furrr` package: integrate with `purrr`

```{r, eval = FALSE}
## purrr / furrr
x %>% map(your_fun)

plan(sequential)
x %>% future_map(your_fun)
```





